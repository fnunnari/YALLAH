import bpy

import os

from typing import List
from typing import Optional

# This is a set of tools to procedurally edit characters generated by MB-Lab.
# All operators are under name space "object.mbast_tools" (the original MBLab operators are under mbast)


R_HAND_NAME = "hand_R"
L_HAND_NAME = "hand_L"

# The animation containing the pose with the relaxed fingers
RELAXED_FINGER_ANIM = "relaxed_fingers_anim.json"


#
# Phenotype tests
def is_female(mesh_obj: bpy.types.Object) -> bool:
    mesh = mesh_obj.data  # type: bpy.types.Mesh
    return mesh.name.startswith('MBLab_human_female')


def is_male(mesh_obj: bpy.types.Object) -> bool:
    mesh = mesh_obj.data  # type: bpy.types.Mesh
    return mesh.name.startswith('MBLab_human_male')


def is_mblab_body(mesh_obj: bpy.types.Object) -> bool:
    mesh = mesh_obj.data  # type: bpy.types.Mesh
    return mesh.name.startswith('MBLab_')


def character_prefix(mesh_obj: bpy.types.Object) -> Optional[str]:
    """Get the prefix that has been used to create the character.
    :param mesh_obj: The MESH object, as created and named by MBLab.
    """

    import re

    patt = re.compile("^(.+)_body$")
    res = patt.match(mesh_obj.name)
    if res:
        name = res.group(1)
        return name
    else:
        return None


#
#
#
class SetupMBLabCharacter(bpy.types.Operator):
    """Setup an MB-Lab character to be ready for rendering in real-time and exportation to Unity."""
    bl_idname = "mbast_tools.setup_mblab_character"
    bl_label = "MBLab Tools - Setup MBLab Character"
    bl_options = {'REGISTER', 'INTERNAL', 'UNDO'}

    #
    # DEFINITIONS: SUPPORT FUNCTIONS
    @staticmethod
    def clear_selection(mesh_obj: bpy.types.Object):
        """Make sure that the editor is in the following state:
            * OBJECT_MODE
            * selected: one object, the mesh object.
            * active: the mesh object.
        """

        # Switch to OBJECT mode
        bpy.ops.object.mode_set(mode='OBJECT')
        bpy.ops.object.select_all(action='DESELECT')  # Deselect all objects

        # The MESH object will be the active and the only selected object
        mesh_obj.select_set(True)
        bpy.context.view_layer.objects.active = mesh_obj   

    @classmethod
    def poll(cls, context):
        obj = context.active_object
        if obj is not None:
            if obj.type == 'MESH':
                return True

        return False

    def execute(self, context):
        from yallah import YALLAH_FEATURES_DIR

        mesh_obj = bpy.context.active_object
        assert mesh_obj.type == 'MESH'

        arm_obj = mesh_obj.parent
        if arm_obj is None:
            self.report({'ERROR'}, "Character Mesh must have a parent Armature")
            return {'CANCELLED'}

        if arm_obj.type != 'ARMATURE':
            self.report({'ERROR'}, "Character Mesh parent object {} must be Armature".format(arm_obj.name))
            return {'CANCELLED'}

        assert arm_obj.type == 'ARMATURE'

        char_name = character_prefix(mesh_obj=mesh_obj)
        if char_name is None:
            self.report({'ERROR'}, "Character not properly named (should be, for example: 'Anna_body')."
                                   " Please, use the MBLab prefix during finalization.")
            return {'CANCELLED'}

        #
        # A TEST TO CHECK FOR WORKING DIRECTORIES AND PATHS
        # This is harmless and can be used as template to develop new functionalities
        #
        filepath = os.path.join(YALLAH_FEATURES_DIR, "Test/Setup.py")
        exec(compile(open(filepath).read(), filepath, 'exec'))

        #
        # VIEW MODE TO REAL-TIME RENDERING
        #
        for area in bpy.context.screen.areas:
            if area.type == 'VIEW_3D':
                for space in area.spaces:
                    if space.type == 'VIEW_3D':
                        space.shading.type = 'SOLID'

        #
        # CREATE THE VISEMES FOR TTS
        #
        filepath = os.path.join(YALLAH_FEATURES_DIR, "MaryTTS/Setup.py")
        exec(compile(open(filepath).read(), filepath, 'exec'))

        #
        # CREATE THE Facial Expressions(FE)
        #
        filepath = os.path.join(YALLAH_FEATURES_DIR, "FacialExpressions/Setup.py")
        exec(compile(open(filepath).read(), filepath, 'exec'))

        #
        # CREATE THE BONES NEEDED FOR EYEGAZE CONTROL
        #
        filepath = os.path.join(YALLAH_FEATURES_DIR, "EyeGaze/Setup.py")
        exec(compile(open(filepath).read(), filepath, 'exec'))

        SetupMBLabCharacter.clear_selection(mesh_obj=mesh_obj)

        #
        # CREATE THE BONES NEEDED FOR DYNAMIC CAMERA FRAMING
        #
        filepath = os.path.join(YALLAH_FEATURES_DIR, "Camera/Setup.py")
        exec(compile(open(filepath).read(), filepath, 'exec'))

        SetupMBLabCharacter.clear_selection(mesh_obj=mesh_obj)

        #
        # FIX MATERIALS AND REMOVE THE SURFACE SUBDIVISION MODIFIER
        #
        filepath = os.path.join(YALLAH_FEATURES_DIR, "RealTimeRequirements/Setup.py")
        exec(compile(open(filepath).read(), filepath, 'exec'))

        SetupMBLabCharacter.clear_selection(mesh_obj=mesh_obj)

        #
        # CREATE A REFERENCE A-Pose, with object transform and all bones reset to identity.
        #
        bpy.context.view_layer.objects.active = arm_obj
        bpy.ops.yallah.create_apose_action()

        SetupMBLabCharacter.clear_selection(mesh_obj=mesh_obj)

        #
        # MARK THE SETUP AS DONE
        #
        mesh_obj.yallah_setup_done = True

        return {'FINISHED'}


#
#
# ANIMATION

def list_bones_recursive(b: bpy.types.PoseBone, include_root: bool = True) -> List[bpy.types.PoseBone]:
    out = []

    if include_root:
        out += [b]

    for child in b.children:
        c = list_bones_recursive(child, include_root=True)
        out = out + c

    return out


class RemoveAnimationFromFingers(bpy.types.Operator):
    """Remove all animation curves from the hands of a MBLab character"""
    bl_idname = "mblab_tools.remove_finger_animation"
    bl_label = "MBLab Tools - Remove animation curves for the fingers from the active action"
    bl_options = {'REGISTER', 'INTERNAL', 'UNDO'}

    @classmethod
    def poll(cls, context):

        if not (context.mode == 'POSE' or context.mode == 'OBJECT'):
            return False

        obj = context.active_object  # type: bpy.types.Object
        if obj is not None:
            if obj.type == 'ARMATURE':
                anim_data = obj.animation_data
                if anim_data is not None:
                    act = anim_data.action
                    if act is not None:
                        return True

        return False

    def execute(self, context):
        import re

        # Active Armature
        arm_obj = context.active_object  # type: bpy.types.Object

        # Get hand bones
        if R_HAND_NAME not in arm_obj.pose.bones:
            self.report({'ERROR'}, "No bone named '{}' in armature {}".format(R_HAND_NAME, arm_obj.name))
            return {'CANCELLED'}

        if L_HAND_NAME not in arm_obj.pose.bones:
            self.report({'ERROR'}, "No bone named '{}' in armature {}".format(L_HAND_NAME, arm_obj.name))
            return {'CANCELLED'}

        r_hand_bones = list_bones_recursive(b=arm_obj.pose.bones[R_HAND_NAME], include_root=False)
        l_hand_bones = list_bones_recursive(b=arm_obj.pose.bones[L_HAND_NAME], include_root=False)

        # print(r_hand_bones)
        # print(l_hand_bones)

        all_bones = r_hand_bones + l_hand_bones
        bone_names = [b.name for b in all_bones]
        print("Bones ({}):".format(len(bone_names)))
        print(bone_names)

        act = arm_obj.animation_data.action
        print("Removing animations from action clip '{}'".format(act.name))
        print("Number of curves now: {}".format(len(act.fcurves)))

        #
        # Really remove the animation curves
        # All the bone names in a quick-access set.
        bone_name_set = set(bone_names)
        curves_to_remove = []  # type: List[bpy.types.FCurve]
        # Prepare a regular expression to extract the name of the bone from the data_path
        bone_match_re = re.compile('^pose\.bones\["(.+)"\]\..*')
        for fcurve in act.fcurves:  # type: bpy.types.FCurve
            # print("Curve "+fcurve.data_path)

            match_res = bone_match_re.match(fcurve.data_path)
            if match_res is not None:
                data_path_bone = match_res.group(1)
                # print("Matched Bone: " + data_path_bone)

                if data_path_bone in bone_name_set:
                    curves_to_remove.append(fcurve)

        for fc in curves_to_remove:
            # print("Removing" + fc.data_path)
            act.fcurves.remove(fc)

        print("Number of curves after removal: {}".format(len(act.fcurves)))

        return {'FINISHED'}


class SetRelaxedPoseToFingers(bpy.types.Operator):
    """Insert a key frame on the current action to set the finger in relaxed pose."""
    bl_idname = "mblab_tools.set_finger_relaxed"
    bl_label = "MBLab Tools - Insert a key frame on the current action to set the finger in relaxed pose."
    bl_options = {'REGISTER', 'INTERNAL', 'UNDO'}

    @classmethod
    def poll(cls, context):

        if not (context.mode == 'POSE' or context.mode == 'OBJECT'):
            return False

        obj = context.active_object  # type: bpy.types.Object
        if obj is not None:
            if obj.type == 'ARMATURE':
                anim_data = obj.animation_data
                if anim_data is not None:
                    act = anim_data.action
                    if act is not None:
                        return True

        return False

    def execute(self, context):

        import json
        from mathutils import Quaternion

        from yallah import YALLAH_DATA_DIR

        arm = context.active_object  # type: bpy.types.Object
        assert arm.type == 'ARMATURE'

        with open(os.path.join(YALLAH_DATA_DIR, RELAXED_FINGER_ANIM), 'r') as relaxed_finger_anim_file:
            relaxed_finger_anim = json.load(fp=relaxed_finger_anim_file)

        if type(relaxed_finger_anim) != dict:
            self.report({'ERROR'}, "File '{}' should contain a dictionary at top level".format(RELAXED_FINGER_ANIM))
            return {'CANCELLED'}

        for data_path in relaxed_finger_anim.keys():  # type: str
            if data_path.endswith('rotation_quaternion'):
                quat = arm.path_resolve(data_path)  # type: Quaternion
                data_path_indices = relaxed_finger_anim[data_path]
                # For each of the 4 quaternion components, set its value in the current pose.
                for idx in range(4):
                    data = data_path_indices[str(idx)]
                    kf0 = data[0]
                    # t = kf0[0]  # this is the timestamp
                    v = kf0[1]  # this is the value of the quaternion element
                    # Really set the value for the quaternion
                    quat[idx] = v

                arm.keyframe_insert(data_path=data_path, frame=1, group="fingers")

        return {'FINISHED'}


class ResetCharacterPose(bpy.types.Operator):
    """Reset character main transformations and all pose bones transformations to identity."""
    bl_idname = "mblab_tools.reset_character_pose"
    bl_label = "MBLab Tools - Reset the character pose."
    bl_options = {'REGISTER', 'INTERNAL', 'UNDO'}

    @classmethod
    def poll(cls, context):

        if not (context.mode == 'POSE' or context.mode == 'OBJECT'):
            return False

        obj = context.active_object  # type: bpy.types.Object
        if obj is not None:
            if obj.type == 'ARMATURE':
                return True

        return False

    def execute(self, context):

        arm_obj = context.active_object  # type: bpy.types.Object
        assert arm_obj.type == 'ARMATURE'

        arm_obj.location = 0, 0, 0
        arm_obj.rotation_quaternion = 1, 0, 0, 0
        arm_obj.rotation_euler = 0, 0, 0
        arm_obj.scale = 1, 1, 1

        for pbone in arm_obj.pose.bones:  # type: bpy.types.PoseBone
            pbone.location = 0, 0, 0
            pbone.rotation_quaternion = 1, 0, 0, 0
            pbone.rotation_euler = 0, 0, 0
            pbone.scale = 1, 1, 1

        return {'FINISHED'}


#
# (UN)REGISTER
#
def register():

    # This property will be use to mark when a character has received the Setup procedure.
    bpy.types.Object.yallah_setup_done =\
        bpy.props.BoolProperty(name="yallah_setup_done",
                               description="When true, the character has already undergone the YALLAH Setup process",
                               default=False)

    bpy.utils.register_class(SetupMBLabCharacter)
    bpy.utils.register_class(RemoveAnimationFromFingers)
    bpy.utils.register_class(SetRelaxedPoseToFingers)
    bpy.utils.register_class(ResetCharacterPose)


def unregister():
    bpy.utils.unregister_class(SetupMBLabCharacter)
    bpy.utils.unregister_class(RemoveAnimationFromFingers)
    bpy.utils.unregister_class(SetRelaxedPoseToFingers)
    bpy.utils.unregister_class(ResetCharacterPose)

    del bpy.types.Object.yallah_setup_done


if __name__ == "__main__":
    register()
